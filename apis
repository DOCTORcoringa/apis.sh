import os
import shutil
import sys
import subprocess
import string
import random
import json
import re
import time
import argparse
import zipfile
from io import BytesIO

from concurrent.futures import ThreadPoolExecutor, as_completed

try:
    import requests
    from colorama import Fore, Style
except ImportError:
    print("\tAlgumas dependÃªncias nÃ£o puderam ser importadas (possivelmente nÃ£o instaladas)")
    print("Digite `pip3 install -r requirements.txt` para instalar todos os pacotes requeridos")
    sys.exit(1)


def readisdc():
    with open("isdcodes.json") as file:
        isdcodes = json.load(file)
    return isdcodes


def get_version():
    try:
        with open(".version", "r") as f:
            return f.read().strip()
    except Exception:
        return '4.0.0.0'


def clr():
    if os.name == "nt":
        os.system("cls")
    else:
        os.system("clear")


def bann_text():
    clr()
    logo = "DCL ğŸ‡±ğŸ‡»"
    if ASCII_MODE:
        logo = ""
    version = "VersÃ£o: " + __VERSION__
    contributors = "Criador: >SPAM>ğŸ–‹ï¸ğŸš¨"
    creator_link = "GitHub: https://github.com/DOCTORcoringa"
    print(random.choice(ALL_COLORS) + logo + RESET_ALL)
    print(version)
    print(contributors)
    print(creator_link)
    print()


def check_intr():
    try:
        requests.get("https://motherfuckingwebsite.com")
    except Exception:
        bann_text()
        print("ConexÃ£o com a internet ruim detectada")
        sys.exit(2)


def format_phone(num):
    num = [n for n in num if n in string.digits]
    return ''.join(num).strip()


def do_zip_update():
    print("AtualizaÃ§Ã£o via ZIP estÃ¡ desativada nesta versÃ£o.")
    print("Por favor, atualize manualmente se necessÃ¡rio.")
    sys.exit()


def do_git_update():
    success = False
    try:
        print(ALL_COLORS[0]+"ATUALIZANDO "+RESET_ALL, end='')
        process = subprocess.Popen("git checkout . && git pull ",
                                   shell=True,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        while process:
            print(ALL_COLORS[0]+'.'+RESET_ALL, end='')
            time.sleep(1)
            returncode = process.poll()
            if returncode is not None:
                break
        success = not process.returncode
    except Exception:
        success = False
    print("\n")

    if success:
        print("DCL ğŸ‡±ğŸ‡» foi atualizado para a Ãºltima versÃ£o")
        print("Por favor, execute o script novamente para carregar a nova versÃ£o")
    else:
        print("NÃ£o foi possÃ­vel atualizar o DCL ğŸ‡±ğŸ‡».")
        print("Certifique-se de ter o 'git' instalado e tente novamente")
    sys.exit()


def update():
    if shutil.which('git'):
        do_git_update()
    else:
        do_zip_update()
    with open(".version", "w") as f:
        f.write("4.0.0.1")
    print("DCL ğŸ‡±ğŸ‡» foi atualizado para a versÃ£o 4.0.0.1")
    print("Por favor, execute o programa novamente para carregar a nova versÃ£o")
    sys.exit()


def check_for_updates():
    if DEBUG_MODE:
        print("MODO DEBUG ativado! VerificaÃ§Ã£o automÃ¡tica de atualizaÃ§Ã£o desativada.")
        return
    print("Checando por atualizaÃ§Ãµes")
    fver = requests.get(
        "https://raw.githubusercontent.com/TheSpeedX/TBomb/master/.version"
    ).text.strip()
    if fver != __VERSION__:
        print("Uma atualizaÃ§Ã£o estÃ¡ disponÃ­vel")
        print("Iniciando atualizaÃ§Ã£o...")
        update()
    else:
        print("DCL ğŸ‡±ğŸ‡» estÃ¡ atualizado")
        print("Iniciando DCL ğŸ‡±ğŸ‡»")


def notifyen():
    try:
        if DEBUG_MODE:
            url = "https://github.com/TheSpeedX/TBomb/raw/dev/.notify"
        else:
            url = "https://github.com/TheSpeedX/TBomb/raw/master/.notify"
        noti = requests.get(url).text.upper()
        if len(noti) > 10:
            print("NOTIFICAÃ‡ÃƒO: " + noti)
            print()
    except Exception:
        pass


def get_phone_info():
    while True:
        cc = input("Digite o cÃ³digo do paÃ­s (sem +): ")
        cc = format_phone(cc)
        if not country_codes.get(cc, False):
            print(f"O cÃ³digo do paÃ­s ({cc}) que vocÃª digitou Ã© invÃ¡lido ou nÃ£o suportado")
            continue
        target = input("Digite o nÃºmero alvo: +" + cc + " ")
        target = format_phone(target)
        if (len(target) <= 6) or (len(target) >= 12):
            print(f"O nÃºmero de telefone ({target}) que vocÃª digitou Ã© invÃ¡lido")
            continue
        return cc, target


def get_mail_info():
    mail_regex = r'^[a-z0-9]+[\._]?[a-z0-9]+[@]\w+[.]\w{2,3}$'
    while True:
        target = input("Digite o email alvo: ")
        if not re.search(mail_regex, target, re.IGNORECASE):
            print(f"O email ({target}) que vocÃª digitou Ã© invÃ¡lido")
            continue
        return target


def pretty_print(cc, target, success, failed):
    requested = success + failed
    print("Ataque em progresso - Por favor, aguarde")
    print("Mantenha-se conectado Ã  internet durante o ataque")
    print("Alvo         : " + cc + " " + target)
    print("Enviadas    : " + str(requested))
    print("Sucesso     : " + str(success))
    print("Falhas      : " + str(failed))
    print("Esta ferramenta foi feita para fins de pesquisa e estudo")
    print("Criado por >SPAM>ğŸ–‹ï¸ğŸš¨")


def workernode(mode, cc, target, count, delay, max_threads):

    api = APIProvider(cc, target, mode, delay=delay)
    clr()
    print("Preparando o ataque - Por favor, aguarde")
    print("Mantenha-se conectado Ã  internet durante o ataque")
    print("VersÃ£o da API: " + api.api_version)
    print("Alvo        : " + cc + target)
    print("Quantidade  : " + str(count))
    print("Threads     : " + str(max_threads) + " threads")
    print("Delay       : " + str(delay) + " segundos")
    print("Esta ferramenta foi feita para fins de pesquisa e estudo")
    print()
    input("Pressione [CTRL+Z] para pausar o ataque ou [ENTER] para continuar")

    if len(APIProvider.api_providers) == 0:
        print("PaÃ­s ou alvo ainda nÃ£o suportado")
        print("Sinta-se Ã  vontade para nos contatar")
        input("Pressione [ENTER] para sair")
        bann_text()
        sys.exit()

    success, failed = 0, 0
    while success < count:
        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            jobs = []
            for i in range(count - success):
                jobs.append(executor.submit(api.hit))

            for job in as_completed(jobs):
                result = job.result()
                if result is None:
                    print("Limite de ataques para o alvo atingido")
                    print("Tente novamente mais tarde")
                    input("Pressione [ENTER] para sair")
                    bann_text()
                    sys.exit()
                if result:
                    success += 1
                else:
                    failed += 1
                clr()
                pretty_print(cc, target, success, failed)
    print("\n")
    print("Ataque concluÃ­do!")
    time.sleep(1.5)
    bann_text()
    sys.exit()


def selectnode(mode="sms"):
    mode = mode.lower().strip()
    try:
        clr()
        bann_text()
        check_intr()
        check_for_updates()
        notifyen()

        max_limit = {"sms": 500, "call": 15, "mail": 200}
        cc, target = "", ""
        if mode in ["sms", "call"]:
            cc, target = get_phone_info()
            if cc != "91":
                max_limit.update({"sms": 100})
        elif mode == "mail":
            target = get_mail_info()
        else:
            raise KeyboardInterrupt

        limit = max_limit[mode]
        while True:
            try:
                message = f"Digite a quantidade de {mode.upper()} para enviar (MÃ¡x {limit}): "
                count = int(input(message).strip())
                if count > limit or count == 0:
                    print(f"VocÃª solicitou {count} {mode.upper()}")
                    print(f"Valor serÃ¡ automaticamente limitado a {limit}")
                    count = limit
                delay = float(input("Digite o tempo de delay (em segundos): ").strip())
                max_thread_limit = (count // 10) if (count // 10) > 0 else 1
                max_threads = int(input(f"Digite o nÃºmero de threads (Recomendado: {max_thread_limit}): ").strip())
                max_threads = max_threads if (max_threads > 0) else max_thread_limit
                if count < 0 or delay < 0:
                    raise Exception
                break
            except KeyboardInterrupt:
                raise
            except Exception:
                print("Leia as instruÃ§Ãµes com atenÃ§Ã£o!!!")
                print()

        workernode(mode, cc, target, count, delay, max_threads)
    except KeyboardInterrupt:
        print("InterrupÃ§Ã£o detectada - Encerrando...")
        sys.exit()


mesgdcrt = None
if sys.version_info[0] != 3:
    print("Este programa requer Python 3")
    sys.exit()

try:
    country_codes = readisdc()["isdcodes"]
except FileNotFoundError:
    update()


__VERSION__ = get_version()
__CONTRIBUTORS__ = ['>SPAM>ğŸ–‹ï¸ğŸš¨']

ALL_COLORS = [Fore.GREEN, Fore.RED, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN, Fore.WHITE]
RESET_ALL = Style.RESET_ALL

ASCII_MODE = False
DEBUG_MODE = False

description = """DCL ğŸ‡±ğŸ‡» - Seu Aplicativo AmigÃ¡vel de Spam

DCL ğŸ‡±ğŸ‡» pode ser usado para vÃ¡rios propÃ³sitos, incluindo:
\t Expor APIs vulnerÃ¡veis na Internet
\t Spam AmigÃ¡vel
\t Testar seu Detector de Spam e mais...

DCL ğŸ‡±ğŸ‡» nÃ£o Ã© destinado a usos maliciosos.
"""

parser = argparse.ArgumentParser(description=description,
                                 epilog='Criado por >SPAM>ğŸ–‹ï¸ğŸš¨')
parser.add_argument("-sms", "--sms", action="store_true",
                    help="Iniciar DCL ğŸ‡±ğŸ‡» no modo SMS")
parser.add_argument("-call", "--call", action="store_true",
                    help="Iniciar DCL ğŸ‡±ğŸ‡» no modo chamada")
parser.add_argument("-mail", "--mail", action="store_true",
                    help="Iniciar DCL ğŸ‡±ğŸ‡» no modo email")
parser.add_argument("-ascii", "--ascii", action="store_true",
                    help="Mostrar apenas caracteres do conjunto ASCII padrÃ£o")
parser.add_argument("-u", "--update", action="store_true",
                    help="Atualizar o DCL ğŸ‡±ğŸ‡»")
parser.add_argument("-c", "--contributors", action="store_true",
                    help="Mostrar criadores atuais")
parser.add_argument("-v", "--version", action="store_true",
                    help="Mostrar versÃ£o atual do DCL ğŸ‡±ğŸ‡»")


if __name__ == "__main__":
    args = parser.parse_args()
    if args.ascii:
        ASCII_MODE = True
    if args.version:
        print("VersÃ£o: ", __VERSION__)
    elif args.contributors:
        print("Criadores: ", " ".join(__CONTRIBUTORS__))
    elif args.update:
        update()
    elif args.mail:
        selectnode(mode="mail")
    elif args.call:
        selectnode(mode="call")
    elif args.sms:
        selectnode(mode="sms")
    else:
        choice = ""
        options = {"1": "SMS", "2": "CALL", "3": "MAIL"}
        try:
            while choice not in options:
                clr()
                bann_text()
                print("OpÃ§Ãµes disponÃ­veis:\n")
                for key, val in options.items():
                    print(f"[ {key} ] {val} BOMB")
                print()
                choice = input("Digite sua escolha : ")
            selectnode(mode=options[choice].lower())
        except KeyboardInterrupt:
            print("InterrupÃ§Ã£o detectada - Encerrando...")
            sys.exit()
    sys.exit()

